# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LyF4ua4THjf3cRnv--ejyWmNMR5kSRux
"""



# BNN results analysis code
# acquire classes and instances of confidence below a certain percentage

low_images = [] # empty list for images
lowPP = [] # empty list for probabilities
low_supposed_label = [] # empty list for predicted labels

def analyse_prediction_low(data, true_labels, model, image_num, n, run_ensemble=False):
    if run_ensemble:
        ensemble_size = 200 # Bayesian
    else:
        ensemble_size = 1 # Probabilistic
    image = data[image_num]
    true_label = true_labels[image_num]
    predicted_probabilities = np.empty(shape=(ensemble_size, n))
    for i in range(ensemble_size):
        predicted_probabilities[i] = model(image[np.newaxis,:]).mean().numpy()[0]

    model_prediction = model(image[np.newaxis, :]) # for high level collection adjust to above desired probability instead of below
    if np.all(predicted_probabilities <= 0.7): # this example is 70%, adjust for other runs

      low_images.append(image_num)
      lowPP.append(predicted_probabilities[i]) # add instances to lists
      low_supposed_label.append(true_label)
    return low_images
    return lowPP
    return low_supposed_label


for i in range(4000): # adjust figure to number of images in test set
    analyse_prediction_low(X_test, Y_test, probabilistic_model, i, n)

def low_results_table(low_images, lowPP, low_supposed_label):
    confidence_vals = [] # empty list for confidence values
    conf = [arr.tolist() for arr in lowPP] # array to list
    for i in range(len(conf)): # iterate through conf list
        max_value = max(conf[i]) # take max value
        confidence_vals.append(max_value) # add to empty list
    conf_index = np.array(conf) # return to array
    Prob_index = np.argmax(conf_index, axis=1)
    predicted_label = Prob_index.tolist()


# create dataframe
df_results = pd.DataFrame(list(zip (low_images, confidence_vals,
predicted_label, low_supposed_label)),
columns =['Image', 'Confidence', 'Predicted',
'True'])
print(df_results['Confidence'].max()) # print desired results
#print(df_results['Confidence'].min())
print (df_results['True'].value_counts())
df_results.groupby(['Predicted']).size().plot(kind = "bar") # plot which classes were most wrongly predicted
return df_results


# acquire and plot confidence averages

AllPP = [] # create empty list of predicted probabilities
Allsupposed_label = [] # create empty list of all supposed labels

def all_predictions(data, true_labels, model, image_num, n,
run_ensemble=False):
    if run_ensemble:
        ensemble_size = 200 # Bayesian
    else:
        ensemble_size = 1 # Probabilistic
    image = data[image_num] # image data X
    true_label = true_labels[image_num] # get true Y labels
    predicted_probabilities = np.empty(shape=(ensemble_size, n))
    for i in range(ensemble_size):
    predicted_probabilities[i] = model(image[np.newaxis,
    :]).mean().numpy()[0]

model_prediction = model(image[np.newaxis, :])
if np.any(predicted_probabilities >= 0): # collect all probabilities in order to average

    AllPP.append(predicted_probabilities[i]) # add to lists
    Allsupposed_label.append(true_label)

return AllPP
return Allsupposed_label

for i in range(4000): # adjust figure to number of images in test set
  all_predictions(X_test, Y_test, probabilistic_model, i, n)

PP_avg = [] # empty list for averages
for i in AllPP:
  max_PPS = max(i) # take maximum
  PP_avg.append(max_PPS) # add to list

df_averages = pd.DataFrame(list(zip(PP_avg, Allsupposed_label)), # zip average probabilities with the predicted label
columns =['AvgProb', 'Class'])
group_avgs = []

for i in range(n):
  df_avg_list = df_averages[df_averages['Class'] == i]
  group_avgs.append(df_avg_list["AvgProb"].mean())
  df_totals = pd.DataFrame(list(zip(reset_list, group_avgs)),
  columns=['Class','AvgProb'])

# create bar plot and adjust colours according to class
df_totals.plot('Class', 'AvgProb', kind='bar', color=['C2', 'C2', 'C2', 'C2','C3','C3','C3'])